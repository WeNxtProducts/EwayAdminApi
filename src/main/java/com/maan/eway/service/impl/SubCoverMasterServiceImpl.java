/*
*  Copyright (c) 2019. All right reserved
* Created on 2022-08-24 ( Date ISO 2022-08-24 - Time 12:58:26 )
* Generated by Telosys Tools Generator ( version 3.3.0 )
*/
package com.maan.eway.service.impl;

import java.math.BigDecimal;
import java.sql.Timestamp;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Comparator;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.dozer.DozerBeanMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.google.gson.Gson;
import com.maan.eway.bean.CoverMaster;
import com.maan.eway.bean.ListItemValue;
import com.maan.eway.error.Error;
import com.maan.eway.master.req.SubCoverChangeStatusReq;
import com.maan.eway.master.req.SubCoverMasterGetAllReq;
import com.maan.eway.master.req.SubCoverMasterGetReq;
import com.maan.eway.master.req.SubCoverMasterSaveReq;
import com.maan.eway.master.res.SubCoverMasterGetAllRes;
import com.maan.eway.master.res.SubCoverMasterGetRes;
import com.maan.eway.master.service.SubCoverMasterService;
import com.maan.eway.repository.CoverMasterRepository;
import com.maan.eway.repository.ListItemValueRepository;
import com.maan.eway.res.SuccessRes;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.TypedQuery;
import jakarta.persistence.criteria.CriteriaBuilder;
import jakarta.persistence.criteria.CriteriaQuery;
import jakarta.persistence.criteria.Order;
import jakarta.persistence.criteria.Predicate;
import jakarta.persistence.criteria.Root;
import jakarta.persistence.criteria.Subquery;

/**
 * <h2>ReferalMasterServiceimpl</h2>
 */
@Service
@Transactional
public class SubCoverMasterServiceImpl implements SubCoverMasterService {

	@PersistenceContext
	private EntityManager em;

	Gson json = new Gson();

	@Autowired
	private CoverMasterRepository repo;
	

	
	@Autowired
	private ListItemValueRepository listRepo;


	private Logger log = LogManager.getLogger(SubCoverMasterServiceImpl.class);

	//************************************************INSERT/UPDATE COVER DETAILS******************************************************\\
	@Override
	public List<Error> validateSubCover(SubCoverMasterSaveReq req){
	List<Error> errorList = new ArrayList<Error>();
	try {

		if(StringUtils.isBlank(req.getCoverId())  ) {
			errorList.add(new Error("01", "CoverId", "Please Select Cover Id"));
		} else if (StringUtils.isBlank(req.getSubCoverName()) ) {
			errorList.add(new Error("02", "SubCoverName", "Please Select Sub Cover  Name "));
		}else if (req.getSubCoverName().length() > 100){
			errorList.add(new Error("02","SubCoverName", "Please Enter Sub Cover  Name within 100 Characters")); 
		}else if (StringUtils.isBlank(req.getSubCoverId())) {
			List<CoverMaster> SubCoverList = getSubCoverNameExistDetails(req.getSubCoverName() , req.getCoverId() , null);
			if (SubCoverList.size()>0 ) {
				errorList.add(new Error("01", "Sub Cover  Name", "This Sub Cover  Name Already Exist "));
			}
		}else  {
			List<CoverMaster> SubCoverList =  getSubCoverNameExistDetails(req.getSubCoverName(),req.getCoverId() , req.getSubCoverId() );
			if (SubCoverList.size()>0 &&  (! req.getCoverId().equalsIgnoreCase(SubCoverList.get(0).getCoverId().toString())) ) {
				errorList.add(new Error("01", "Sub Cover  Name", "This Sub Cover  Name Already Exist "));
			}
		}
		if (StringUtils.isBlank(req.getCoverBasedOn())) {
			errorList.add(new Error("01", "CoverBasedOn", "Please Select CoverBasedOn "));
		}
		if (StringUtils.isNotBlank(req.getDependentCoverYn()) && req.getDependentCoverYn().equalsIgnoreCase("Y") ) {
			if (StringUtils.isBlank(req.getDependentCoverId()) ) {
				errorList.add(new Error("08", "Dependent Cover Id", "Please Select Dependent Cover Id"));
			}
		}
		
		if (StringUtils.isBlank(req.getSubCoverDesc())) {
			errorList.add(new Error("03", "SubCoverDesc", "Please Enter Sub Cover Desc"));
		}
		if (StringUtils.isBlank(req.getRegulatoryCode())) {
			errorList.add(new Error("04", "Regulatory Code", "Please Enter Regulatory Code"));
		} else if (req.getRegulatoryCode().length() > 20) {
			errorList.add(new Error("04", "Regulatory Code", "Enter Regulatory Code  within 20 Characters Only"));
		}
		// Date Validation 
		Calendar cal = new GregorianCalendar();
		Date today = new Date();
		cal.setTime(today);cal.add(Calendar.DAY_OF_MONTH, -1);cal.set(Calendar.HOUR_OF_DAY, 23);cal.set(Calendar.MINUTE, 50);
		today = cal.getTime();
		if (req.getEffectiveDateStart() == null ) {
			errorList.add(new Error("04", "EffectiveDateStart", "Please Enter Effective Date Start "));

		} else if (req.getEffectiveDateStart().before(today)) {
			errorList.add(new Error("04", "EffectiveDateStart", "Please Enter Effective Date Start as Future Date"));
		}
		if(StringUtils.isNotBlank(req.getCoverageType()) && req.getCoverageType().equalsIgnoreCase("P") ) {
			if (req.getEffectiveDateEnd()==null) {
				errorList.add(new Error("14", "EffectiveDateEnd", "Please Enter EffectiveDateEnd"));
			}else if (req.getEffectiveDateStart()!=null && req.getEffectiveDateEnd()!=null) {
				if( req.getEffectiveDateStart().after(req.getEffectiveDateEnd())) {
					errorList.add(new Error("14", "EffectiveDateEnd", "EffectiveDateStart After EffectiveDateEnd Not Allwoed"));	
				}
				
			}
		}
		
//		else if (req.getEffectiveDateEnd() == null ) {
//			errorList.add(new Error("10", "EffectiveDateEnd", "Please Enter Effective Date End "));
//
//		} else if (req.getEffectiveDateEnd().before(req.getEffectiveDateStart()) || req.getEffectiveDateEnd().equals(req.getEffectiveDateStart())) {
//			errorList.add(new Error("10", "EffectiveDateStart", "Please Enter Effective Date End  is After Effective Date Start"));
//		} 
		
		
		if (req.getRemarks().length() > 100) {
			errorList.add(new Error("05", "Remarks", "Please Enter Remarks within 100 Characters"));
		}

		if (StringUtils.isBlank(req.getCreatedBy())) {
			errorList.add(new Error("07", "CreatedBy", "Please Enter CreatedBy "));
		} else if (req.getCreatedBy().length() > 100) {
			errorList.add(new Error("07", "CreatedBy", "Please Enter CreatedBy within 100 Characters"));
		}

		//Status Validation
		if (StringUtils.isBlank(req.getStatus())) {
			errorList.add(new Error("05", "Status", "Please Select Status  "));
		} else if (req.getStatus().length() > 1) {
			errorList.add(new Error("05", "Status", "Please Select Valid Status - One Character Only Allwed"));
		}else if(!("Y".equalsIgnoreCase(req.getStatus())||"N".equalsIgnoreCase(req.getStatus())||"R".equalsIgnoreCase(req.getStatus())|| "P".equalsIgnoreCase(req.getStatus()))) {
			errorList.add(new Error("05", "Status", "Please Select Valid Status - Active or Deactive or Pending or Referral "));
		}
		
		if (StringUtils.isBlank(req.getRemarks())) {
			errorList.add(new Error("09", "Remarks", "Please Enter Remarks"));
		} else if (req.getRemarks().length() > 100) {
			errorList.add(new Error("09", "Remarks", "Enter Remarks  within 100 Characters Only"));
		}
		
		// Rating Master Validation
		if (StringUtils.isBlank(req.getCoverageType())) {
			errorList.add(new Error("09", "CoverageType", "Please Select CoverageType"));
		}
		
		if (StringUtils.isBlank(req.getSumInsuredStart())) {
			errorList.add(new Error("09", "SumInsuredStart", "Please Enter Min Sum"));
		} else if (! req.getSumInsuredStart().matches("[0-9.]+") ) {
			errorList.add(new Error("09", "SumInsuredStart", "Please Enter Valid Number In CoverageLimit "));
		} else if (StringUtils.isBlank(req.getCoverageLimit())) {
			errorList.add(new Error("09", "CoverageLimit", "Please Enter CoverageLimit"));
		} else if (! req.getCoverageLimit().matches("[0-9.]+") ) {
			errorList.add(new Error("09", "CoverageLimit", "Please Enter Valid Number In CoverageLimit "));
		} else if (  Double.valueOf(req.getSumInsuredStart()) > Double.valueOf(req.getCoverageLimit()) ) {
			errorList.add(new Error("09", "CoverageLimit", "Min Suminsured Greater Than CoverageLimit Not Allowed "));
		}
		
		if (StringUtils.isBlank(req.getExcessPercent())) {
			errorList.add(new Error("09", "Excess Percent ", "Please Enter Excess Percent"));
		} else if (! req.getExcessPercent().matches("[0-9.]+") ) {
			errorList.add(new Error("09", "Excess Percent", "Please Enter Valid Number In Excess Percent"));
		}
		if (StringUtils.isBlank(req.getExcessAmount())) {
			errorList.add(new Error("10", "Excess Amount ", "Please Enter Excess Amount"));
		} else if (! req.getExcessAmount().matches("[0-9.]+") ) {
			errorList.add(new Error("10", "Excess Amount", "Please Enter Valid Number In Excess Amount"));
		}
		if (StringUtils.isBlank(req.getExcessDesc())) {
			errorList.add(new Error("11", "Excess Desc ", "Please Enter Excess Desc"));
		}
		else if (req.getExcessDesc().length() > 500) {
			errorList.add(new Error("11", "Excess Desc", "Enter Excess Desc  within 500 Characters Only"));
		}
		
		if (StringUtils.isBlank(req.getCalcType())) {
			errorList.add(new Error("09", "CalcType", "Please Select CalcType"));
		} 
		
		// Tax Calculation
		if (StringUtils.isBlank(req.getIsTaxExcempted())) {
			errorList.add(new Error("08", "IsTaxExcempted", "Please Enter Is Tax Excempted"));
		} else if (req.getIsTaxExcempted().length() > 1) {
			errorList.add(new Error("08", "IsTaxExcempted", "Enter Is Tax Excempted in 1 Character Only"));
		} else if (!("Y".equals(req.getIsTaxExcempted()) || "N".equals(req.getIsTaxExcempted()))) {
			errorList.add(new Error("08", "IsTaxExcempted", "Enter Is Tax Excempted Y or N Only"));
			
		} else if(req.getIsTaxExcempted().equalsIgnoreCase("Y") ){
			if (StringUtils.isBlank(req.getTaxExcemptionReference())) {
				errorList.add(new Error("08", "TaxExcemptionReference", "Please Enter Tax Excemption Reference"));
			} else if (req.getTaxExcemptionReference().length() >100 ) {
				errorList.add(new Error("08", "TaxExcemptionReference", "100 Chatracters Only Allowed As Tax Excemption Reference"));
			} 
			
			if (StringUtils.isBlank(req.getTaxExcemptionType())) {
				errorList.add(new Error("08", "TaxExcemptionType", "Please Select Tax Excemption Type"));
			} else if (! req.getTaxExcemptionType().matches( "[0-9]+") ) {
				errorList.add(new Error("08", "TaxExcemptionType", "Please Select Tax Excemption Type"));
			} 
		} else if(req.getIsTaxExcempted().equalsIgnoreCase("N") ){
			if (StringUtils.isBlank(req.getTaxAmount())) {
				errorList.add(new Error("08", "TaxAmount", "Please Enter TaxAmount"));
			} else if (! req.getTaxAmount().matches( "[0-9.]+") ) {
				errorList.add(new Error("08", "TaxAmount", "Please Enter Valid Tax Amount"));
			} 
			
			if (StringUtils.isBlank(req.getTaxCode())) {
				errorList.add(new Error("08", "TaxCode", "Please Enter Tax Code "));
			} else if (req.getTaxCode().length() >100 ) {
				errorList.add(new Error("08", "TaxCode", "100 Chatracters Only Allowed As Tax Code "));
			} 
		}
		
		if (StringUtils.isNotBlank(req.getCalcType()) &&  ( req.getCalcType().equalsIgnoreCase("F") || req.getCalcType().equalsIgnoreCase("FD")) ) {
			
		/*	if( StringUtils.isBlank(req.getFactorTypeId()) ) {
				errorList.add(new Error("09", "Factor Type Id", "Please Enter Factor Type Id "));
			
			} */
	
		} else  {
			
			if (StringUtils.isBlank(req.getBaseRate())) {
				errorList.add(new Error("09", "BaseRate", "Please Enter BaseRate" ));
			} else if (! req.getBaseRate().matches("[0-9.]+") ) {
				errorList.add(new Error("09", "BaseRate", "Please Enter Valid Number In BaseRate"));
			}
//			
//			if (StringUtils.isBlank(req.getSumInsuredStart())) {
//				errorList.add(new Error("09", "SumInsuredStart", "Please Enter SumInsuredStart"));
//			} else if (! req.getSumInsuredStart().matches("[0-9.]+") ) {
//				errorList.add(new Error("09", "SumInsuredStart", "Please Enter Valid Number In SumInsuredStart"));
//			} 
			/*else if (StringUtils.isBlank(req.getSumInsuredEnd())) {
				errorList.add(new Error("09", "SumInsuredEnd", "Please Enter SumInsuredEnd"));
			} else if (! req.getSumInsuredEnd().matches("[0-9.]+") ) {
				errorList.add(new Error("09", "SumInsuredEnd", "Please Enter Valid Number In SumInsuredEnd"));
			}/*  else if (Double.valueOf(req.getMinimumPremium())  > Double.valueOf(req.getSumInsuredEnd())  ) {
			errorList.add(new Error("09", "SumInsuredEnd", "SumInsuredEnd must be greater than MinimumPremium "));
		} */
			
			if (StringUtils.isBlank(req.getMinimumPremium())) {
				errorList.add(new Error("09", "MinimumPremium", "Please Enter MinimumPremium"));
			} else if (! req.getMinimumPremium().matches("[0-9.]+") ) {
				errorList.add(new Error("09", "MinimumPremium", "Please Enter Valid Number In MinimumPremium"));
			}
		}
		
	} catch (Exception e) {
		log.error(e);
		e.printStackTrace();
		errorList.add(new Error("11", "Common Error", e.getMessage()));

	}
	return errorList;
}
	
		@Transactional
		@Override
		public SuccessRes insertSubCover(SubCoverMasterSaveReq req) {
			SuccessRes res = new SuccessRes();
			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
			List<CoverMaster> list = new ArrayList<CoverMaster>();
			DozerBeanMapper dozerMapper = new DozerBeanMapper(); 
			try {
				List<ListItemValue> calcTypes = getListItem("99999" , "99999", "CALCULATION_TYPE");
				List<ListItemValue> coverageTypes = getListItem("99999" , "99999" , "COVERAGE_TYPE");
				List<ListItemValue> taxExcemptionType = getListItem("99999" , "99999" , "TAX_EXEMPTION_TYPE");
				
				Integer amendId=0;
				Date startDate = req.getEffectiveDateStart() ;
				String end = "31/12/2050";
				Date endDate =  req.getCoverageType().equalsIgnoreCase("P") && req.getEffectiveDateEnd()!=null ? req.getEffectiveDateEnd() : sdf.parse(end);
				long MILLIS_IN_A_DAY = 1000 * 60 * 60 * 24;
				Date oldEndDate = new Date(req.getEffectiveDateStart().getTime() - MILLIS_IN_A_DAY);
				Date entryDate = null ;
				String createdBy = "" ;
				
				CoverMaster coverDetails = new CoverMaster(); 
				
				{// Cover Details
					CriteriaBuilder cb = em.getCriteriaBuilder();
					CriteriaQuery<CoverMaster> query = cb.createQuery(CoverMaster.class);
					//Find all
					Root<CoverMaster> b = query.from(CoverMaster.class);
					//Select 
					query.select(b);
//					
					// Order By
					List<Order> orderList = new ArrayList<Order>();
					orderList.add(cb.desc(b.get("effectiveDateStart")));
					
					// Where
				//	Predicate n1 = cb.equal(b.get("effectiveDateStart"), effectiveDate);
					Predicate n2 = cb.equal(b.get("coverId"), req.getCoverId());
					Predicate n3 = cb.equal(b.get("subCoverId"),"0");
					
					
					query.where(n2,n3).orderBy(orderList);
					
					// Get Result 
					TypedQuery<CoverMaster> result = em.createQuery(query);
					int limit = 0 , offset = 2 ;
					result.setFirstResult(limit * offset);
					result.setMaxResults(offset);
					List<CoverMaster> coverlist = result.getResultList();
					coverDetails = coverlist.get(0);
					
				}
				
				Integer subcoverId=0 ;
				String coverId = req.getCoverId();
				
				CoverMaster saveData = new CoverMaster();
				if( StringUtils.isBlank(req.getSubCoverId())  ) {
						
					Long totalCount = getSubCoverMasterTableCount( req.getCoverId());
					subcoverId = Integer.valueOf(String.valueOf(totalCount+1001)) ;
					entryDate = new Date();
					createdBy = req.getCreatedBy();
					res.setResponse("Saved Successfully");
					res.setSuccessId(subcoverId.toString());
					
				} else {
					// Update
					subcoverId = Integer.valueOf(req.getSubCoverId());
					CriteriaBuilder cb = em.getCriteriaBuilder();
					CriteriaQuery<CoverMaster> query = cb.createQuery(CoverMaster.class);
					//Find all
					Root<CoverMaster> b = query.from(CoverMaster.class);
					//Select 
					query.select(b);
//					
					// Order By
					List<Order> orderList = new ArrayList<Order>();
					orderList.add(cb.desc(b.get("effectiveDateStart")));
					
					// Where
				//	Predicate n1 = cb.equal(b.get("effectiveDateStart"), effectiveDate);
					Predicate n2 = cb.equal(b.get("coverId"), req.getCoverId());
					Predicate n3 = cb.equal(b.get("subCoverId"), req.getSubCoverId());
					
					
					query.where(n2,n3).orderBy(orderList);
					
					// Get Result 
					TypedQuery<CoverMaster> result = em.createQuery(query);
					int limit = 0 , offset = 2 ;
					result.setFirstResult(limit * offset);
					result.setMaxResults(offset);
					list = result.getResultList();
					
					if(list.size()>0) {
						Date beforeOneDay = new Date(new Date().getTime() - MILLIS_IN_A_DAY);
					
						if ( list.get(0).getEffectiveDateStart().before(beforeOneDay)  ) {
							amendId = list.get(0).getAmendId() + 1 ;
							entryDate = new Date() ;
							createdBy = req.getCreatedBy();
								CoverMaster lastRecord = list.get(0);
								lastRecord.setEffectiveDateEnd(oldEndDate);
								repo.saveAndFlush(lastRecord);
							
						} else {
							amendId = list.get(0).getAmendId() ;
							entryDate = list.get(0).getEntryDate() ;
							createdBy = list.get(0).getCreatedBy();
							saveData = list.get(0) ;
							if (list.size()>1 ) {
								CoverMaster lastRecord = list.get(1);
								lastRecord.setEffectiveDateEnd(oldEndDate);
								repo.saveAndFlush(lastRecord);
							}
						
					    }
					}
					res.setResponse("Updated Successfully");
					res.setSuccessId(subcoverId.toString());
				}
					
				dozerMapper.map(req, saveData);
				saveData.setSubCoverId(subcoverId);
				saveData.setEffectiveDateStart(startDate);
				saveData.setCoverName(coverDetails.getCoverName());
				saveData.setCoverDesc(coverDetails.getCoverDesc());
				saveData.setCoverageType(coverDetails.getCoverageType());
				saveData.setIsSelectedYn(coverDetails.getIsSelectedYn());
				saveData.setProRataYn(StringUtils.isNotBlank(req.getProRataYn()) ?  req.getProRataYn() : coverDetails.getProRataYn() );
				saveData.setRegulatoryCode(StringUtils.isNotBlank(req.getRegulatoryCode()) ?  req.getRegulatoryCode() : coverDetails.getRegulatoryCode() );
				saveData.setMultiSelectYn(coverDetails.getMultiSelectYn() );
				saveData.setEffectiveDateEnd(endDate);
				saveData.setCreatedBy(createdBy);
				saveData.setStatus(req.getStatus());
				saveData.setEntryDate(entryDate);
				saveData.setUpdatedDate(new Date());
				saveData.setUpdatedBy(req.getCreatedBy());
				saveData.setAmendId(amendId);
				saveData.setCoreAppCode(req.getCoreAppCode());
				saveData.setSubCoverYn("Y");
				saveData.setMinSuminsured(StringUtils.isBlank(req.getSumInsuredStart())? BigDecimal.ZERO : new BigDecimal(req.getSumInsuredStart()));
				saveData.setCoverageLimit(StringUtils.isBlank(req.getCoverageLimit())? BigDecimal.ZERO : new BigDecimal(req.getCoverageLimit()));
				saveData.setCodeDescLocal( StringUtils.isNotBlank(req.getCodeDescLocal()) ? req.getCodeDescLocal() : "" );
				
				// Amount Details
			if(req.getCalcType().equalsIgnoreCase("F") || req.getCalcType().equalsIgnoreCase("FD") ) {
				
				//saveData.setFactorTypeId(req.getFactorTypeId()==null ?null : Integer.valueOf(req.getFactorTypeId()));
			}  else if(req.getCalcType().equalsIgnoreCase("P")  ) {
				
				// Amount 
				saveData.setBaseRate(StringUtils.isBlank(req.getBaseRate())? BigDecimal.ZERO :new BigDecimal(req.getBaseRate()));
				saveData.setMinPremium(StringUtils.isBlank(req.getMinimumPremium())? BigDecimal.ZERO :new BigDecimal(req.getMinimumPremium()));
				//saveData.setMaxSuminsured(StringUtils.isBlank(req.getSumInsuredEnd())?BigDecimal.ZERO :new BigDecimal(req.getSumInsuredEnd()));
				//saveData.setMinSuminsured(StringUtils.isBlank(req.getSumInsuredStart())? BigDecimal.ZERO :new BigDecimal(req.getSumInsuredStart()));
					
			} else {
				
				saveData.setBaseRate(StringUtils.isBlank(req.getBaseRate())? BigDecimal.ZERO :new BigDecimal(req.getBaseRate()));
				saveData.setMinPremium(StringUtils.isBlank(req.getMinimumPremium())? BigDecimal.ZERO :new BigDecimal(req.getMinimumPremium()));
				//saveData.setMaxSuminsured(StringUtils.isBlank(req.getSumInsuredEnd())? BigDecimal.ZERO :new BigDecimal(req.getSumInsuredEnd()));
				//saveData.setMinSuminsured(StringUtils.isBlank(req.getSumInsuredStart())? BigDecimal.ZERO :new BigDecimal(req.getSumInsuredStart()));		
			}
			
			saveData.setCoverageLimit(StringUtils.isBlank(req.getCoverageLimit())? BigDecimal.ZERO :new BigDecimal(req.getCoverageLimit()));
			saveData.setExcessAmount(StringUtils.isBlank(req.getExcessAmount())?BigDecimal.ZERO : new BigDecimal(req.getExcessAmount()));
			saveData.setExcessPercent(StringUtils.isBlank(req.getExcessPercent())? BigDecimal.ZERO : new BigDecimal(req.getExcessPercent()));
			saveData.setExcessDesc(StringUtils.isBlank(req.getExcessDesc())?"":req.getExcessDesc());			
			saveData.setCalcTypeDesc(calcTypes.stream().filter( o -> o.getItemCode().equalsIgnoreCase(req.getCalcType()) ).collect(Collectors.toList()).get(0).getItemValue());
			saveData.setCoverageTypeDesc(coverageTypes.stream().filter( o -> o.getItemCode().equalsIgnoreCase(req.getCoverageType()) ).collect(Collectors.toList()).get(0).getItemValue());
			if(  req.getIsTaxExcempted().equalsIgnoreCase("Y") ) {
				saveData.setTaxExcemptionReference(req.getTaxExcemptionReference());
				saveData.setTaxExcemptionType(req.getTaxExcemptionType());
				saveData.setTaxExcemptionTypeDesc(taxExcemptionType.stream().filter( o -> o.getItemCode().equalsIgnoreCase(req.getTaxExcemptionType()) ).collect(Collectors.toList()).get(0).getItemValue());
				saveData.setTaxAmount(null);
				saveData.setTaxCode(null);
			} else if(req.getIsTaxExcempted().equalsIgnoreCase("N")  ) {
				saveData.setTaxExcemptionReference(null);
				saveData.setTaxExcemptionType(null);
				saveData.setTaxExcemptionTypeDesc(null);
				saveData.setTaxAmount(req.getTaxAmount()==null ? BigDecimal.ZERO :new BigDecimal(req.getTaxAmount()));
				saveData.setTaxCode(req.getTaxCode());
			}

			saveData.setDependentCoverYn(StringUtils.isNotBlank(req.getDependentCoverYn()) ? req.getDependentCoverYn() : "N" );
			saveData.setProRataYn( StringUtils.isNotBlank(req.getProRataYn() ) ? req.getProRataYn()  : "N");
			List<ListItemValue> proRataTypes =  getListItem("99999" , saveData.getProRataYn()   ,"PRO_RATA_TYPE");
			String proRata = saveData.getProRataYn() ;
			proRataTypes = proRataTypes.stream().filter( o -> proRata.equalsIgnoreCase(o.getItemCode())   ).collect(Collectors.toList());
			saveData.setProRataDesc(proRataTypes.size() > 0 ? proRataTypes.get(0).getItemValue() : ""   );
			
			repo.saveAndFlush(saveData);
			log.info("Saved Details is ---> " + json.toJson(saveData));
					
		} catch (Exception e) {
				e.printStackTrace();
				log.info("Exception is --->" + e.getMessage());
				return null;
			}
			return res;
		}

		public synchronized List<ListItemValue> getListItem(String insuranceId , String branchCode, String itemType) {
			List<ListItemValue> list = new ArrayList<ListItemValue>();
			try {
				Date today = new Date();
				Calendar cal = new GregorianCalendar();
				cal.setTime(today);
				today = cal.getTime();
				Date todayEnd = cal.getTime();
				
				// Criteria
				CriteriaBuilder cb = em.getCriteriaBuilder();
				CriteriaQuery<ListItemValue> query=  cb.createQuery(ListItemValue.class);
				// Find All
				Root<ListItemValue> c = query.from(ListItemValue.class);
				
				//Select
				query.select(c);
				// Order By
				List<Order> orderList = new ArrayList<Order>();
				orderList.add(cb.asc(c.get("branchCode")));
				
				
				// Effective Date Start Max Filter
				Subquery<Timestamp> effectiveDate = query.subquery(Timestamp.class);
				Root<ListItemValue> ocpm1 = effectiveDate.from(ListItemValue.class);
				effectiveDate.select(cb.greatest(ocpm1.get("effectiveDateStart")));
				Predicate a1 = cb.equal(c.get("itemId"),ocpm1.get("itemId"));
				Predicate a2 = cb.lessThanOrEqualTo(ocpm1.get("effectiveDateStart"), today);
				Predicate a5 = cb.equal(c.get("companyId"),ocpm1.get("companyId"));
				Predicate a6 = cb.equal(c.get("branchCode"),ocpm1.get("branchCode"));
				effectiveDate.where(a1,a2,a5,a6);
				// Effective Date End Max Filter
				Subquery<Timestamp> effectiveDate2 = query.subquery(Timestamp.class);
				Root<ListItemValue> ocpm2 = effectiveDate2.from(ListItemValue.class);
				effectiveDate2.select(cb.greatest(ocpm2.get("effectiveDateEnd")));
				Predicate a3 = cb.equal(c.get("itemId"),ocpm2.get("itemId"));
				Predicate a7 = cb.equal(c.get("companyId"),ocpm2.get("companyId"));
				Predicate a8 = cb.equal(c.get("branchCode"),ocpm2.get("branchCode"));
				Predicate a4 = cb.greaterThanOrEqualTo(ocpm2.get("effectiveDateEnd"), todayEnd);
				effectiveDate2.where(a3,a4,a7,a8);
							
				// Where
				Predicate n1 = cb.equal(c.get("status"),"Y");
				Predicate n11 = cb.equal(c.get("status"),"R");
				Predicate n12 = cb.or(n1,n11);
				Predicate n2 = cb.equal(c.get("effectiveDateStart"),effectiveDate);
				Predicate n3 = cb.equal(c.get("effectiveDateEnd"),effectiveDate2);	
				Predicate n4 = cb.equal(c.get("companyId"),insuranceId);
		//		Predicate n5 = cb.equal(c.get("companyId"), "99999");
				Predicate n6 = cb.equal(c.get("branchCode"),branchCode);
				Predicate n7 = cb.equal(c.get("branchCode"), "99999");
			//	Predicate n8 = cb.or(n4,n5);
				Predicate n9 = cb.or(n6,n7);
				Predicate n10 = cb.equal(c.get("itemType"),itemType);
				query.where(n12,n2,n3,n4,n9,n10).orderBy(orderList);
				// Get Result
				TypedQuery<ListItemValue> result = em.createQuery(query);
				list = result.getResultList();
				
				list = list.stream().filter(distinctByKey(o -> Arrays.asList(o.getItemCode()))).collect(Collectors.toList());
				list.sort(Comparator.comparing(ListItemValue :: getItemValue));
			} catch (Exception e) {
				e.printStackTrace();
				log.info("Exception is ---> " + e.getMessage());
				return null;
			}
			return list ;
		}
		
		private static <T> java.util.function.Predicate<T> distinctByKey(java.util.function.Function<? super T, ?> keyExtractor) {
		    Map<Object, Boolean> seen = new ConcurrentHashMap<>();
		    return t -> seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
		}
		
		
	public Long getSubCoverMasterTableCount(String coverId  ) {

	Long data = 0L;
	try {

		List<Long> list = new ArrayList<Long>();
		// Find Latest Record
		CriteriaBuilder cb = em.getCriteriaBuilder();
		CriteriaQuery<Long> query = cb.createQuery(Long.class);

		// Find All
		Root<CoverMaster> b = query.from(CoverMaster.class);

		// Select
		query.multiselect(cb.count(b));

		// Effective Date Max Filter
		Subquery<Timestamp> effectiveDate = query.subquery(Timestamp.class);
		Root<CoverMaster> ocpm1 = effectiveDate.from(CoverMaster.class);
		effectiveDate.select(cb.greatest(ocpm1.get("effectiveDateStart")));
		Predicate a1 = cb.equal(ocpm1.get("subCoverId"), b.get("subCoverId"));
		Predicate a2 = cb.equal(ocpm1.get("coverId"), b.get("coverId"));
		effectiveDate.where(a1,a2);

		Predicate n1 = cb.equal(b.get("effectiveDateStart"), effectiveDate);
		Predicate n2 = cb.equal(b.get("coverId") , coverId);
		Predicate n3 = cb.notEqual(b.get("subCoverId") , "0");
		query.where(n1,n2,n3);
		// Get Result
		TypedQuery<Long> result = em.createQuery(query);
		list = result.getResultList();

		data = list.get(0);

	} catch (Exception e) {
		e.printStackTrace();
		log.info(e.getMessage());

	}
	return data;
	}
	
	public List<CoverMaster> getSubCoverNameExistDetails(String subCoverName , String coverId , String subCoverId ) {
		List<CoverMaster> list = new ArrayList<CoverMaster>();
		try {
			// Find Latest Record
			CriteriaBuilder cb = em.getCriteriaBuilder();
			CriteriaQuery<CoverMaster> query = cb.createQuery(CoverMaster.class);
	
			// Find All
			Root<CoverMaster> b = query.from(CoverMaster.class);
	
			// Select
			query.select(b);
	
			// Effective Date Max Filter
			Subquery<Timestamp> effectiveDate = query.subquery(Timestamp.class);
			Root<CoverMaster> ocpm1 = effectiveDate.from(CoverMaster.class);
			effectiveDate.select(cb.greatest(ocpm1.get("effectiveDateStart")));
			Predicate a1 = cb.equal(ocpm1.get("subCoverId"), b.get("subCoverId"));
			Predicate a2 = cb.equal(ocpm1.get("coverId"),b.get("coverId"));
			effectiveDate.where(a1,a2);
	
			Predicate n1 = cb.equal(b.get("effectiveDateStart"), effectiveDate);
			Predicate n2 = cb.equal(b.get("subCoverName"), subCoverName );	
			Predicate n3 = cb.equal(b.get("coverId"), coverId );
			if( StringUtils.isBlank(subCoverId)) {
				query.where(n1,n2,n3);	
			} else {
				Predicate n4 = cb.equal(b.get("subCoverId"), subCoverId );
				query.where(n1,n2,n3,n4);
			}
			
			// Get Result
			TypedQuery<CoverMaster> result = em.createQuery(query);
			list = result.getResultList();		
		
		} catch (Exception e) {
			e.printStackTrace();
			log.info(e.getMessage());
	
		}
		return list;
	}
	
	///*********************************************************************GET ALL******************************************************\\
	@Override
	public List<SubCoverMasterGetAllRes> getallSubCover(SubCoverMasterGetAllReq req) {
	List<SubCoverMasterGetAllRes> resList = new ArrayList<SubCoverMasterGetAllRes>();
	DozerBeanMapper dozerMapper = new  DozerBeanMapper();
	try {
		List<CoverMaster> coverList = new ArrayList<CoverMaster>();
		
		// Find Latest Record
		CriteriaBuilder cb = em.getCriteriaBuilder();
		CriteriaQuery<CoverMaster> query = cb.createQuery(CoverMaster.class);

		// Find All
		Root<CoverMaster> b = query.from(CoverMaster.class);

		// Select
		query.select(b);

		// Effective Date Max Filter
		Subquery<Long> amendId = query.subquery(Long.class);
		Root<CoverMaster> ocpm1 = amendId.from(CoverMaster.class);
		amendId.select(cb.max(ocpm1.get("amendId")));
		Predicate a1 = cb.equal(ocpm1.get("subCoverId"), b.get("subCoverId"));
		Predicate a2 = cb.equal(ocpm1.get("coverId"), b.get("coverId"));
		amendId.where(a1,a2);

		// Order By
		List<Order> orderList = new ArrayList<Order>();
		orderList.add(cb.asc(b.get("subCoverName")));
		
		// Where
		Predicate n1 = cb.equal(b.get("amendId"), amendId);
		Predicate n2 = cb.equal(b.get("coverId"), req.getCoverId());
		Predicate n3 = cb.notEqual(b.get("subCoverId"),"0");
		query.where(n1,n2,n3).orderBy(orderList);

		// Get Result
		TypedQuery<CoverMaster> result = em.createQuery(query);
		coverList = result.getResultList();
		
		// Map
		for (CoverMaster data : coverList) {
			SubCoverMasterGetAllRes res = new SubCoverMasterGetAllRes();

			res = dozerMapper.map(data, SubCoverMasterGetAllRes.class);
			resList.add(res);
		}

	} catch (Exception e) {
		e.printStackTrace();
		log.info(e.getMessage());
		return null;

	}
	return resList;
	}

	///*********************************************************************GET BY ID******************************************************\\
	@Override
	public SubCoverMasterGetRes getBySubCoverId(SubCoverMasterGetReq req) {
		SubCoverMasterGetRes res = new SubCoverMasterGetRes();
		DozerBeanMapper dozerMapper = new  DozerBeanMapper();
		String pattern = "#####0.00";
		DecimalFormat df = new DecimalFormat(pattern);
		
	try {
		// Find Latest Record
		CriteriaBuilder cb = em.getCriteriaBuilder();
		CriteriaQuery<CoverMaster> query = cb.createQuery(CoverMaster.class);

		// Find All
		Root<CoverMaster> b = query.from(CoverMaster.class);

		// Select
		query.select(b);

		// Effective Date Max Filter
		Subquery<Long> amendId = query.subquery(Long.class);
		Root<CoverMaster> ocpm1 = amendId.from(CoverMaster.class);
		amendId.select(cb.max(ocpm1.get("amendId")));
		Predicate a1 = cb.equal(ocpm1.get("subCoverId"), b.get("subCoverId"));
		Predicate a2 = cb.equal(ocpm1.get("coverId"), b.get("coverId"));
		amendId.where(a1,a2);

		// Order By
		List<Order> orderList = new ArrayList<Order>();
		orderList.add(cb.asc(b.get("subCoverName")));
		
		// Where
		Predicate n1 = cb.equal(b.get("amendId"), amendId);
		Predicate n2 = cb.equal(b.get("coverId"), req.getCoverId());
		Predicate n3 = cb.equal(b.get("subCoverId"),req.getSubCoverId());
		query.where(n1,n2,n3).orderBy(orderList);

		// Get Result
		TypedQuery<CoverMaster> result = em.createQuery(query);
		List<CoverMaster> list = result.getResultList();
					
		res = dozerMapper.map(list.get(0) , SubCoverMasterGetRes.class);
		res.setSubCoverId(String.valueOf(list.get(0).getSubCoverId()));
		res.setEntryDate(list.get(0).getEntryDate());
		res.setEffectiveDateStart(list.get(0).getEffectiveDateStart());
		res.setExcessPercent(list.get(0).getExcessPercent() == null ? "" :df.format(list.get(0).getExcessPercent()));
		res.setExcessAmount(list.get(0).getExcessAmount() == null ? "" :df.format(list.get(0).getExcessAmount()));
		res.setExcessDesc(list.get(0).getExcessDesc() == null ? "" :list.get(0).getExcessDesc());
		res.setMinimumPremium(list.get(0).getMinPremium() == null ? "" :df.format(list.get(0).getMinPremium()));
		res.setSumInsuredStart(list.get(0).getMinSuminsured() == null ? "" :df.format(list.get(0).getMinSuminsured()));
		res.setBaseRate(list.get(0).getBaseRate() == null ? "" : df.format(list.get(0).getBaseRate()));
		res.setCoverageLimit(list.get(0).getCoverageLimit() == null ? "" : df.format(list.get(0).getCoverageLimit()));
		
		if (null != list && !list.isEmpty() && StringUtils.isNotBlank(list.get(0).getCodeDescLocal())) {
			res.setCodeDescLocal(list.get(0).getCodeDescLocal());
		}		
			
	} catch (Exception e) {
		e.printStackTrace();
		log.info("Exception is ---> " + e.getMessage());
		return null;
	}
	return res;
	}

	//************************************************GET ACTIVE COVER******************************************\\
	@Override
	public List<SubCoverMasterGetAllRes> getActiveSubCover(SubCoverMasterGetAllReq req) {
		List<SubCoverMasterGetAllRes> resList = new ArrayList<SubCoverMasterGetAllRes>();
		DozerBeanMapper dozerMapper = new  DozerBeanMapper();
		try {
			List<CoverMaster> coverList = new ArrayList<CoverMaster>();
			
			// Find Latest Record
			CriteriaBuilder cb = em.getCriteriaBuilder();
			CriteriaQuery<CoverMaster> query = cb.createQuery(CoverMaster.class);

			// Find All
			Root<CoverMaster> b = query.from(CoverMaster.class);

			// Select
			query.select(b);

			// Effective Date Max Filter
			Subquery<Long> amendId = query.subquery(Long.class);
			Root<CoverMaster> ocpm1 = amendId.from(CoverMaster.class);
			amendId.select(cb.max(ocpm1.get("amendId")));
			Predicate a1 = cb.equal(ocpm1.get("subCoverId"), b.get("subCoverId"));
			Predicate a2 = cb.equal(ocpm1.get("coverId"), b.get("coverId"));
			amendId.where(a1,a2);

			// Order By
			List<Order> orderList = new ArrayList<Order>();
			orderList.add(cb.asc(b.get("subCoverName")));
			
			// Where
			Predicate n1 = cb.equal(b.get("amendId"), amendId);
			Predicate n2 = cb.equal(b.get("coverId"), req.getCoverId());
			Predicate n3 = cb.notEqual(b.get("subCoverId"),"0");
			Predicate n4 = cb.equal(b.get("status"),"Y");
			query.where(n1,n2,n3,n4).orderBy(orderList);

			// Get Result
			TypedQuery<CoverMaster> result = em.createQuery(query);
			coverList = result.getResultList();
			
			// Map
			for (CoverMaster data : coverList) {
				SubCoverMasterGetAllRes res = new SubCoverMasterGetAllRes();
				res = dozerMapper.map(data, SubCoverMasterGetAllRes.class);
				if (StringUtils.isNotBlank(data.getCodeDescLocal())) {
					res.setCodeDescLocal(data.getCodeDescLocal());
				}
				resList.add(res);
			}

		} catch (Exception e) {
			e.printStackTrace();
			log.info(e.getMessage());
			return null;

		}
		return resList;
		}
	
	@Override
	public SuccessRes changeStatusOfSubCover(SubCoverChangeStatusReq req) {
		SuccessRes res = new SuccessRes();
		try {
			List<CoverMaster> list = new ArrayList<CoverMaster>();
			
			// Find Latest Record
			CriteriaBuilder cb = em.getCriteriaBuilder();
			CriteriaQuery<CoverMaster> query = cb.createQuery(CoverMaster.class);
			// Find all
			Root<CoverMaster> b = query.from(CoverMaster.class);
			//Select
			query.select(b);

			// Amend ID Max Filter
			Subquery<Long> amendId = query.subquery(Long.class);
			Root<CoverMaster> ocpm1 = amendId.from(CoverMaster.class);
			amendId.select(cb.max(ocpm1.get("amendId")));
			Predicate a1 = cb.equal(ocpm1.get("coverId"), b.get("coverId"));
			Predicate a2 = cb.equal(ocpm1.get("subCoverId"), b.get("subCoverId"));
			
			amendId.where(a1, a2);

			// Order By
			List<Order> orderList = new ArrayList<Order>();
			orderList.add(cb.asc(b.get("subCoverId")));

			// Where
			Predicate n1 = cb.equal(b.get("amendId"), amendId);
			Predicate n2 = cb.equal(b.get("coverId"),req.getCoverId());
			Predicate n3 = cb.equal(b.get("subCoverId"), req.getSubCoverId());
			
			query.where(n1,n2,n3).orderBy(orderList);
			
			// Get Result 
			TypedQuery<CoverMaster> result = em.createQuery(query);
			list = result.getResultList();
			CoverMaster updateRecord = list.get(0);
			
			updateRecord.setStatus(req.getStatus());
			repo.save(updateRecord);
			
			
			res.setResponse("Status Changed");
			res.setSuccessId(req.getSubCoverId());
		} catch(Exception e ) {
			e.printStackTrace();
			log.info("Exception is ---> " + e.getMessage());
			return null;
		}
		return res;
	}
	
	

}